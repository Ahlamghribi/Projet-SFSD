#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

// Structure pour représenter une date
typedef struct {
    int jour, mois, annee;
} date;

// Structure pour représenter un enregistrement (médicament)
typedef struct {
    char nom[20];
    int qte;
    float prix;
    int reference;
    char ingredient[30];
    date datefabr, dateexp;
} Medicament;

// Structure pour représenter un bloc de données
typedef struct {
    int nb;  // Nombre d'enregistrements dans le bloc
    Medicament enregistrements[10];  // Ajustez la taille en fonction de vos besoins
} Bloc;

// Structure pour représenter l'entête du fichier
typedef struct {
    int nbrenrg;  // Nombre total d'enregistrements dans le fichier
    int nbbloc;   // Nombre total de blocs dans le fichier
} Entete;


// Fonction pour calculer la taille d'un enregistrement logique
int tailleEnregistrement(Medicament med) {
    // Ajustez la taille en fonction de la structure réelle de vos enregistrements
    return sizeof(char) * 20 + sizeof(int) + sizeof(float) + sizeof(int) + sizeof(char) * 30 + sizeof(date) * 2;
}

// Fonction pour calculer la taille d'un bloc
int tailleBloc(Bloc bloc) {
    int taille = sizeof(int);  // Taille du champ "nb" dans le bloc

    for (int i = 0; i < bloc.nb; i++) {
        taille += tailleEnregistrement(bloc.enregistrements[i]);
    }

    return taille;
}

// Fonction pour comparer deux références pour la recherche dichotomique
int comparerReferences(const void *a, const void *b) {
    return ((Medicament *)a)->reference - ((Medicament *)b)->reference;
}

 
// Fonction pour ajouter un enregistrement à un bloc de manière ordonnée
bool ajouterAuBloc(Bloc *bloc, Medicament med) {
    int tailleEnreg = tailleEnregistrement(med);

    if (tailleBloc(*bloc) + tailleEnreg <= 500) {
        // Insérer l'enregistrement à la bonne position en maintenant l'ordre
        int position = 0;

        while (position < bloc->nb && comparerReferences(&med, &(bloc->enregistrements[position])) > 0) {
            position++;
        }

        // Décaler les enregistrements pour faire de la place pour le nouvel enregistrement
        for (int i = bloc->nb - 1; i >= position; i--) {
            bloc->enregistrements[i + 1] = bloc->enregistrements[i];
        }

        bloc->enregistrements[position] = med;
        bloc->nb++;
         int comparerReferences();
        // Trier le bloc après l'insertion
        qsort(bloc->enregistrements, bloc->nb, sizeof(Medicament), comparerReferences);

        return true;
    }

    return false;
}

// Fonction pour enregistrer un bloc dans le fichier
void enregistrerBloc(FILE *fichier, Bloc bloc, Entete *entete) {
    fseek(fichier, entete->nbbloc * sizeof(Bloc), SEEK_SET);
    fwrite(&bloc, sizeof(Bloc), 1, fichier);

    entete->nbbloc++;
}


// Fonction pour rechercher un médicament par référence (dichotomique)
Medicament rechercherMedicament(FILE *fichier, int reference) {
    fseek(fichier, 0, SEEK_SET);

    Entete entete;
    fread(&entete, sizeof(Entete), 1, fichier);

    Bloc bloc;

    for (int i = 0; i < entete.nbbloc; i++) {
        fseek(fichier, i * sizeof(Bloc), SEEK_SET);
        fread(&bloc, sizeof(Bloc), 1, fichier);

        // Utiliser la recherche dichotomique à l'intérieur de chaque bloc
        int debut = 0;
        int fin = bloc.nb - 1;

        while (debut <= fin) {
            int milieu = debut + (fin - debut) / 2;

            if (bloc.enregistrements[milieu].reference == reference) {
                return bloc.enregistrements[milieu]; // Médicament trouvé
            }

            if (bloc.enregistrements[milieu].reference < reference) {
                debut = milieu + 1;
            } else {
                fin = milieu - 1;
            }
        }
    }

    // Retourner un médicament vide si la référence n'est pas trouvée
    Medicament medicamentVide = {"", 0, 0.0, 0, "", {0, 0, 0}, {0, 0, 0}};
    return medicamentVide;
}

// Fonction pour supprimer un médicament par référence
bool supprimerMedicament(FILE *fichier, int reference) {
    fseek(fichier, 0, SEEK_SET);

    Entete entete;
    fread(&entete, sizeof(Entete), 1, fichier);

    Bloc bloc;

    for (int i = 0; i < entete.nbbloc; i++) {
        fseek(fichier, i * sizeof(Bloc), SEEK_SET);
        fread(&bloc, sizeof(Bloc), 1, fichier);

        for (int j = 0; j < bloc.nb; j++) {
            if (bloc.enregistrements[j].reference == reference) {
                // Supprimer le médicament du bloc
                for (int k = j; k < bloc.nb - 1; k++) {
                    bloc.enregistrements[k] = bloc.enregistrements[k + 1];
                }

                bloc.nb--;

                // Réécrire le bloc modifié dans le fichier
                fseek(fichier, i * sizeof(Bloc), SEEK_SET);
                fwrite(&bloc, sizeof(Bloc), 1, fichier);

                // Mettre à jour le nombre total d'enregistrements
                entete.nbrenrg--;

                // Mettre à jour le nombre total de blocs si le bloc est devenu vide
                if (bloc.nb == 0) {
                    entete.nbbloc--;
                }

                // Réécrire l'entête dans le fichier
                fseek(fichier, 0, SEEK_SET);
                fwrite(&entete, sizeof(Entete), 1, fichier);

                return true;
            }
        }
    }

    return false;  // La référence n'a pas été trouvée
}
 
void afficher(int j) {
    char ch[500];
    while (buf.tab[j] != '#') {
        int i = 0; // Initialiser i à zéro avant chaque nouvelle partie de la chaîne

        printf("Le nom de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0'; // Assurez-vous de terminer la chaîne avec un caractère nul
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter la quantité
        i = 0;
        printf("La quantite de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter le prix
        i = 0;
        printf("Le prix de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter la date de fabrication
        i = 0;
        printf("La date de fabrication (jour mois annee) : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter la date d'expiration
        i = 0;
        printf("La date de l'expiration (jour mois annee) : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
    }
}


void tochar(char ch[500], Medicament med)
{
    int i = 0;

    for (int j = 0; j < sizeof(med.nom); j++)
    {
        ch[i] = med.nom[j];
        i++;
    }
    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d", med.qte);
    i =i+ snprintf(NULL, 0, "%d", med.qte);

    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d", med.reference);
    i += snprintf(NULL, 0, "%d", med.reference);
    ch[i] = '$';
    i++;
    sprintf(&ch[i], "%f", med.prix);
    i += snprintf(NULL, 0, "%f", med.prix);
    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d %d %d", med.datefabr.jour, med.datefabr.mois, med.datefabr.annee);
    i += snprintf(NULL, 0, "%d %d %d", med.datefabr.jour, med.datefabr.mois, med.datefabr.annee);
    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d %d %d", med.dateexp.jour, med.dateexp.mois, med.dateexp.annee);
    i += snprintf(NULL, 0, "%d %d %d", med.dateexp.jour, med.dateexp.mois, med.dateexp.annee);
    ch[i] = '$';
    i++;

    ch[i] = '#';
}
