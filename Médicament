#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

// Structures for date, location, medicament, bloc, and entete

typedef struct {
    int jour, mois, annee;
} date;

typedef struct {
    int i, j;
    bool trouve;
} location;

typedef struct {
    char nom[20];
    int qte;
    float prix;
    int reference;
    date datefabr, dateexp;
} Medicament;

typedef struct {
    char tab[500];
    int nb;
} Bloc;

typedef struct {
    int cas, reference, bloc;
} Index;

typedef struct {
    int nbrenrg, nbbloc;
} entete;

// Function to calculate the size of a record
int taillenrg(Bloc buf, int j) {
    int cmp = 1;

    while (buf.tab[j] != '#') {
        j++;
        cmp++;
    }

    return cmp;
}

// Function to calculate the size of a block
int taillebloc(Bloc buf) {
    int j = 1;

    for (int i = 0; i < buf.nb; i++) {
        j = j + taillenrg(buf, j);
        j++;
    }

    return j;
}

// Function to convert Medicament to char array
void tochar(char ch[500], Medicament med) {
    int i = 0;

    // Convert reference to string
    i += sprintf(&ch[i], "%04d$", med.reference);

    // Add medication name
    strncpy(&ch[i], med.nom, sizeof(med.nom) - 1);
    i += strlen(med.nom);
    ch[i] = '$';
    i++;

    // Convert quantity to string
    i += sprintf(&ch[i], "%d$", med.qte);

    // Convert price to string
    i += sprintf(&ch[i], "%.2f$", med.prix);

    // Convert dates to string
    i += sprintf(&ch[i], "%02d %02d %04d$", med.datefabr.jour, med.datefabr.mois, med.datefabr.annee);
    i += sprintf(&ch[i], "%02d %02d %04d$", med.dateexp.jour, med.dateexp.mois, med.dateexp.annee);

    // Add end of enregistrement character
    ch[i] = '#';
}
void afficher(Bloc buf, int j) {
    char ch[500];
    while (buf.tab[j] != '#') {
        int i = 0;

        // Display medication name
        printf("Le nom de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s\n", ch);
        j++;

        // Display quantity
        i = 0;
        printf("La quantite de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s\n", ch);
        j++;

        // Display price
        i = 0;
        printf("Le prix de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s\n", ch);
        j++;

        // Display date of fabrication
        i = 0;
        printf("La date de fabrication (jour mois annee) : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s\n", ch);
        j++;

        // Display date of expiration
        i = 0;
        printf("La date de l'expiration (jour mois annee) : ");
        while (buf.tab[j] != '$' && buf.tab[j] != '#') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s\n", ch);

        if (buf.tab[j] == '$') {
            j++;
        }

        printf("\n");
    }
}

// Function to extract reference from a string
int ref(char tab[4]) {
    return atoi(tab);
}
location rechercheAvecIndexNonDichotomique(int cle, entete e, Index* index) {
    location l;
    l.trouve = false;

    for (int i = 0; i < e.nbrenrg; i++) {
        if (index[i].reference == cle) {
            l.i = index[i].bloc;
            l.j = index[i].cas;
            l.trouve = true;
            break;
        }
    }

    return l;
}

location rechercheAvecIndex(int cle, FILE* F, entete e, Bloc* buffer, Index* index) {
    location l;
    l.trouve = false;

    for (int i = 0; i < e.nbrenrg; i++) {
        fseek(F, (index[i].bloc - 1) * sizeof(Bloc), SEEK_SET);
        fread(buffer->tab, sizeof(char), sizeof(Bloc), F);

        for (int j = 0; j < buffer->nb; j++) {
            int reference;
            sscanf(&buffer->tab[index[j].cas], "%d", &reference);

            if (reference == cle) {
                l.i = i + 1;
                l.j = j + 1;
                l.trouve = true;
                return l; // Sortir dès qu'on trouve la référence
            }
        }
    }

    return l; // Si on n'a pas trouvé la référence
}




Bloc insertionAvecIndex(FILE* F, Medicament eng, entete* e, Bloc* buffer, Index* index) {
    int j = 1;
    char ch[500];
    tochar(ch, eng);
    location l;
    bool trouve;

    F = fopen("medicaments.dat", "rb+");

    if (e->nbrenrg == 0) {
        fseek(F, 0, SEEK_SET);
        fwrite(ch, sizeof(char), strlen(ch), F);
        for (int k = 0; k <= taillenrg(*buffer, j); k++) {
            buffer->tab[k] = ch[k];
        }
        e->nbrenrg++;

        // Update index
        index[e->nbrenrg].cas = j;
        index[e->nbrenrg].reference = eng.reference;
        index[e->nbrenrg].bloc = e->nbrenrg;

    } else {
        l = rechercheAvecIndex(eng.reference, F, *e, buffer, index);

        if (!l.trouve) {
            fseek(F, (l.i - 1) * sizeof(Bloc), SEEK_SET);
            fread(buffer->tab, sizeof(char), sizeof(Bloc), F);

            while (j <= taillenrg(*buffer, j) && eng.reference > atoi(&buffer->tab[index[j].cas])) {
                j++;
            }

            int t = taillenrg(*buffer, j) - 1;
            while (t > 0) {
                buffer->tab[j + t] = buffer->tab[j + t - 1];
                t--;
            }

            for (int k = 0; k < strlen(ch); k++) {
                buffer->tab[j + k] = ch[k];
            }

            fseek(F, (l.i - 1) * sizeof(Bloc), SEEK_SET);
            fwrite(buffer->tab, sizeof(char), sizeof(Bloc), F);
            e->nbrenrg++;

            // Update index
            for (int k = e->nbrenrg; k >= j + 1; k--) {
                index[k] = index[k - 1];
            }

            // Initialize the values for the newly added index entry
            index[j].cas = 1; // Assuming the reference is the first field in the record
            index[j].reference = eng.reference;
            index[j].bloc = l.i;
        }
    }

    fclose(F);
    return *buffer;
}


// Function for deleting with index
bool suppressionAvecIndex(int reference, FILE* F, entete e, Bloc* buffer, Index* index) {
    location l;
    F = fopen("medicaments.dat", "rb+");

    l = rechercheAvecIndex(reference, F, e, buffer, index);

    bool suppressionReussie = false;

    if (l.trouve) {
        fseek(F, (l.i - 1) * sizeof(Bloc), SEEK_SET);
        fread(buffer->tab, sizeof(char), sizeof(Bloc), F);

        int cmp = taillenrg(*buffer, l.j);
        int k = 1;

        while (buffer->tab[k] != '#' && l.j + cmp < buffer->nb) {
            buffer->tab[k] = buffer->tab[l.j + cmp];
            k++;
            cmp++;
        }

        while (k <= 500) {
            buffer->tab[k] = '*';
            k++;
        }

        fseek(F, (l.i - 1) * sizeof(Bloc), SEEK_SET);
        fwrite(buffer->tab, sizeof(char), sizeof(Bloc), F);

        e.nbrenrg--;

        // Update index
        for (int i = l.j; i <= e.nbrenrg; i++) {
            index[i] = index[i + 1];
        }

        suppressionReussie = true;
    }

    fclose(F);
    return suppressionReussie;
}
