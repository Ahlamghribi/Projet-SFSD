// fonction recherche dechotomique version 1


 void ref (int tab[4])
 {
     int s=0;
   for (int i=0;i<=3;i++)
   {
       s=s*10+tab[i];
   }
   return s;
 }


void recherche (int cle,FILE *F,entete e)
{
  F = fopen("sfsd.txt","rb+");

    int bi = 0;
 // int bs = entet(F,1,e);
    int bs = e.nbbloc;
    bool trouve=0;
    bool stop=0;
    int tab[4];
    int i=1;
    int cmp=0;
    int k=1;
    int j;
    int a,z,d;
    int inf,sup;
    bloc buffer;
while(bi<=bs && !trouve && !stop)
{
   i=(bi+bs)/2;
   fseek(F,i*500,SEEK_SET);
   fread(buffer.buff,sizeof(char),500,F);
        while(cmp<buffer.nbe-1)
        {
            if (buffer.buff[k]=='#')//caractere qui separe les enregistrements
            {
                cmp=cmp+1;
            }
            k=k+1;
        }
        // calcule de reference de enregistrement 1
      for (int l=0;l<=3;l++)
        {
         tab[l]=buffer.buff[l+1];
        }
    a=ref(tab);// a c'est la reference de l'enregistrement 1

       for (int l=0;l<=3;l)
        {
         tab[l]=buffer.buff[k];
         k=k+1;
        }
    z=ref(tab);// c'est la reference de le dernnier enregistrement dans le bloc

    if(cle>=a && cle<=z)
    {
        inf=1;
        sup=buffer.nbe;


    while(inf<sup && !trouve)
    {
        j=(inf+sup)/2;
        cmp=1;
        k=1;
        while(cmp<j)
        {
            if(buffer.buff[k]='#')//caractere de fin de enregistrement
            {
                cmp=cmp+1;
            }
         k=k+1;
        }
         for (int l=0;l<=3;l)

         {
             tab[l]=buffer.buff[k];
             k=k+1;
         }

         d=ref(tab);// la reference de l'enregistrement millieu
         if(d==cle)
         {
             trouve= 1;
         }
         else
         {
           if(cle<d)
           {
               //sup=sup-1;
               sup=j-1;
           }
           else
           {
              // inf=inf+1;
              inf =j+1
           }
         }

    }

    if(inf>=sup)
    {
        j=inf;
    }
    stop=1;
    }
    else
    {
        if(val<a)
        {
            bs=i-1;
        }
        else
        {
            bi=i+1;
        }
    }
}
if(bi>bs)
{
    i=bi;
    j=1;
}
fclose(F);
return trouve,i,j;
}
// fonction recherche avec l'index

int rechercheIndex (int cle,index[1000],entet e)
{
 int  gauche = 0;
 int  droite = e.nbenreg-1;
  while ( gauche <= droite)
   {
      milieu = (gauche + droite)/2;
    if (index[milieu].reference == cle)
    {
       return (milieu);
    }
    else
     {
    if (index[milieu].reference > cle)
        {
        droite = milieu - 1;
        }
    else
        {
        gauche = milieu + 1;
        }
     }
   }
    return (droite);
}
// recherche dechotomique 2


Medicament rechercherMedicament(FILE *fichier, int reference) {
    fseek(fichier, 0, SEEK_SET);

    Entete entete;
    fread(&entete, sizeof(Entete), 1, fichier);

    Bloc bloc;

    for (int i = 0; i < entete.nbbloc; i++) {
        fseek(fichier, i * sizeof(Bloc), SEEK_SET);
        fread(&bloc, sizeof(Bloc), 1, fichier);

        // Utiliser la recherche dichotomique à l'intérieur de chaque bloc
        int debut = 0;
        int fin = bloc.nb - 1;

        while (debut <= fin) {
            int milieu = debut + (fin - debut) / 2;

            if (bloc.enregistrements[milieu].reference == reference) {
                return bloc.enregistrements[milieu]; // Médicament trouvé
            }

            if (bloc.enregistrements[milieu].reference < reference) {
                debut = milieu + 1;
            } else {
                fin = milieu - 1;
            }
        }
    }

    // Retourner un médicament vide si la référence n'est pas trouvée
    Medicament medicamentVide = {"", 0, 0.0, 0, "", {0, 0, 0}, {0, 0, 0}};
    return medicamentVide;
}
