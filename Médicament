#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
 
// Structure pour représenter une date
typedef struct {
    int jour, mois, annee;
} date;

// Structure pour représenter un enregistrement (médicament)
typedef struct {
    char nom[20];
    int qte;
    float prix;
    int reference;
    char ingredient[30];
    date datefabr, dateexp;
} Medicament;

// Structure pour représenter un bloc de données
typedef struct {
    int nb;  // Nombre d'enregistrements dans le bloc
    Medicament enregistrements[10];  // Ajustez la taille en fonction de vos besoins
} Bloc;

// Structure pour représenter l'entête du fichier
typedef struct {
    int nbrenrg;  // Nombre total d'enregistrements dans le fichier
    int nbbloc;   // Nombre total de blocs dans le fichier
} Entete;


// Fonction pour calculer la taille d'un enregistrement logique
int tailleEnregistrement(Medicament med) {
    // Ajustez la taille en fonction de la structure réelle de vos enregistrements
    return sizeof(char) * 20 + sizeof(int) + sizeof(float) + sizeof(int) + sizeof(char) * 30 + sizeof(date) * 2;
}

// Fonction pour calculer la taille d'un bloc
int tailleBloc(Bloc bloc) {
    int taille = sizeof(int);  // Taille du champ "nb" dans le bloc

    for (int i = 0; i < bloc.nb; i++) {
        taille += tailleEnregistrement(bloc.enregistrements[i]);
    }

    return taille;
}
 

void Suppression(int reference,FILE* fichier,entete e) { 
    bool trouv;
    int i, j;
    Bloc buf;

    f = fopen(nomfich, "rb+");

    Rech(reference, nomfich, trouv, i, j);
    int cmp = taillenrg(buf.tab,j);
    if (trouv) {
        fseek(f, i * sizeof(Bloc), SEEK_SET);
        fread(&buf, sizeof(Bloc), 1, f);

      while (!feof(fichier)) {

            if (taillebloc(buf) +taillenrg(buf.tab,j+cmp+1)-taillenrg(buf.tab,j) <= 500) { //est ce que n9dro ndiro enregistrement jdid f placeto wyekfina place
                while (buf.tab[cmp] != '#') {
                    buf.tab[j] = buf.tab[j+cmp];
                    j++;  
               //suppression logique
                while (j<=500) {
                    buf.tab[j] = '*';
                    j++;
                }
                j++;
               // si le debut de l'enregistrement n'est pas dans le debut de bloc et il y'a de l'espace on le décale
                if (j!=j+cmp+1)
                {

                        while(buf.tab[j+cmp]!='#')
                    {
                        buf.tab[j]=buf.tab[j+cmp];
                        j++;
                    }
                    j++; 
                }
                }
            else
            { 
             fseek(f, (i+1) * sizeof(Bloc), SEEK_SET);
             fwrite(&buf, sizeof(Bloc), 1, f);
            while (buf.tab[j+cmp] != '#')
            {
             buf.tab[j] = buf.tab[j+cmp];
             j++;
            }
            j=j+cmp;
            }
            }
           buf.tab[j+1] = '#';


        fseek(f, i * sizeof(Bloc), SEEK_SET);
        fwrite(&buf, sizeof(Bloc), 1, f);

        e.nbrenrg--;
    }
    
    fclose(f);
}

// suppression en utilisant l'index
typedef struct {
 
int reference ,cas,bloc;

}index;
  
void Suppression(int reference, FILE* fichier,index index[1000],entete e) {
    FILE *f; int i;//num de bloc 
    Bloc buf;
    f = fopen(nomfich, "rb+");
    int r=rechercheIndex (int reference,index[1000],entete e); // numero enregistrement
    int j=index[r].cas;
    int i=index[r].bloc;
    
    fseek(f,i* sizeof(Bloc), SEEK_SET);
    fread(&buf, sizeof(Bloc), 1, f); // averifier 
    int cmp = taillenrg(buf.tab,j);  
        while (!feof(fichier)) 
        { 
            if (taillebloc(buf) +taillenrg(buf.tab,j+cmp+1)-taillenrg(buf.tab,j)> 500) { //est ce que n9dro ndiro enregistrement jdid f placeto wyekfina place 
                fseek(f,(i+1)* sizeof(Bloc), SEEK_SET); //acceder a le nouveau bloc
                fread(&buf, sizeof(Bloc), 1, f); 
                
                 //suppression logique 
                while (j<=500) {
                    buf.tab[j] = '*';
                    j++; 
                }
                j++;
               // si le debut de l'enregistrement n'est pas dans le debut de bloc et il y'a de l'espace on le décale
                if (j!=j+cmp+1)
                {
                
                        while(buf.tab[j+cmp]!='#')
                    {
                        buf.tab[j]=buf.tab[j+cmp];
                    j++;
                    }
                    j++;
                
                } //update tableau d'index 
                        index[l]=index[l+1];
                        index[l].cas=j;
//décalage
                 for (int l=r+1;l<e.nbrenrg;l++)
                {
                         index[l]=index[l+1];
                }
            }
            
    else  //il y'a de l'espace 
        {
                //decalage 
                while (buf.tab[j+cmp] != '#') {
                    buf.tab[j] = buf.tab[j+cmp];
                    j++; 
                }
                 
                
                //modification du tableau d'index 
                for (int l=r;l<e.nbrenrg;l++)
                { 
                        index[l].bloc--;
                        index[l].cas=j; 
                } 
                j=j+cmp;
            }  
}
          
        }
        e.nbrenrg--; 
        buf.tab[j]='#';
        fseek(f, i * sizeof(Bloc), SEEK_SET);
        fwrite(&buf, sizeof(Bloc), 1, f);
    }

    fclose(f);
}
void afficher(int j) {
    char ch[500];
    while (buf.tab[j] != '#') {
        int i = 0; // Initialiser i à zéro avant chaque nouvelle partie de la chaîne

        printf("Le nom de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0'; // Assurez-vous de terminer la chaîne avec un caractère nul
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter la quantité
        i = 0;
        printf("La quantite de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter le prix
        i = 0;
        printf("Le prix de medicaments : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter la date de fabrication
        i = 0;
        printf("La date de fabrication (jour mois annee) : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
        j++;

        // Réinitialiser i à zéro avant de traiter la date d'expiration
        i = 0;
        printf("La date de l'expiration (jour mois annee) : ");
        while (buf.tab[j] != '$') {
            ch[i] = buf.tab[j];
            j++;
            i++;
        }
        ch[i] = '\0';
        printf("%s", ch);
        printf("\n");
    }
}


void tochar(char ch[500], Medicament med)
{
    int i = 0;

    for (int j = 0; j < sizeof(med.nom); j++)
    {
        ch[i] = med.nom[j];
        i++;
    }
    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d", med.qte);
    i =i+ snprintf(NULL, 0, "%d", med.qte);

    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d", med.reference);
    i += snprintf(NULL, 0, "%d", med.reference);
    ch[i] = '$';
    i++;
    sprintf(&ch[i], "%f", med.prix);
    i += snprintf(NULL, 0, "%f", med.prix);
    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d %d %d", med.datefabr.jour, med.datefabr.mois, med.datefabr.annee);
    i += snprintf(NULL, 0, "%d %d %d", med.datefabr.jour, med.datefabr.mois, med.datefabr.annee);
    ch[i] = '$';
    i++;

    sprintf(&ch[i], "%d %d %d", med.dateexp.jour, med.dateexp.mois, med.dateexp.annee);
    i += snprintf(NULL, 0, "%d %d %d", med.dateexp.jour, med.dateexp.mois, med.dateexp.annee);
    ch[i] = '$';
    i++;

    ch[i] = '#';
}
