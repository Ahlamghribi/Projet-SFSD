#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int jour, mois, annee;
} date;

typedef struct {
    char nom[20];
    int qte;
    float prix;
    int reference;
    char ingredient[30];
    date datefabr, dateexp;
} Medicament;

typedef struct {
    int nb;
    Medicament enregistrements[10];
} Bloc;

typedef struct {
    int nbrenrg;
    int nbbloc;
} Entete;

typedef struct {
    int reference, cas, bloc;
} Index;

// Fonction pour calculer la taille d'un enregistrement logique
int tailleEnregistrement(Medicament med) {
    return sizeof(char) * 20 + sizeof(int) + sizeof(float) + sizeof(int) + sizeof(char) * 30 + sizeof(date) * 2;
}

// Fonction pour calculer la taille d'un bloc
int tailleBloc(Bloc bloc) {
    int taille = sizeof(int);

    for (int i = 0; i < bloc.nb; i++) {
        taille += tailleEnregistrement(bloc.enregistrements[i]);
    }

    return taille;
}

// Fonction pour comparer deux références pour la recherche dichotomique
int comparerReferences(const void *a, const void *b) {
    return ((Medicament *)a)->reference - ((Medicament *)b)->reference;
}

// Fonction pour ajouter un enregistrement à un bloc de manière ordonnée
bool ajouterAuBloc(Bloc *bloc, Medicament med) {
    int tailleEnreg = tailleEnregistrement(med);

    if (tailleBloc(*bloc) + tailleEnreg <= 500) {
        int position = 0;

        while (position < bloc->nb && comparerReferences(&med, &(bloc->enregistrements[position])) > 0) {
            position++;
        }

        for (int i = bloc->nb - 1; i >= position; i--) {
            bloc->enregistrements[i + 1] = bloc->enregistrements[i];
        }

        bloc->enregistrements[position] = med;
        bloc->nb++;
        qsort(bloc->enregistrements, bloc->nb, sizeof(Medicament), comparerReferences);

        return true;
    }

    return false;
}

// Fonction pour enregistrer un bloc dans le fichier
void enregistrerBloc(FILE *fichier, Bloc bloc, Entete *entete) {
    fseek(fichier, entete->nbbloc * sizeof(Bloc), SEEK_SET);
    fwrite(&bloc, sizeof(Bloc), 1, fichier);

    entete->nbbloc++;
}


// Fonction pour créer un nouveau médicament
Medicament creerMedicament() {
    Medicament med;

    printf("Nom du medicament: ");
    scanf("%s", med.nom);

    printf("Quantite: ");
    scanf("%d", &med.qte);

    printf("Prix: ");
    scanf("%f", &med.prix);

    printf("Reference: ");
    scanf("%d", &med.reference);

    printf("Ingredient: ");
    scanf("%s", med.ingredient);

    printf("Date de fabrication (jj mm aaaa): ");
    scanf("%d %d %d", &med.datefabr.jour, &med.datefabr.mois, &med.datefabr.annee);

    printf("Date d'expiration (jj mm aaaa): ");
    scanf("%d %d %d", &med.dateexp.jour, &med.dateexp.mois, &med.dateexp.annee);

    return med;
}// Fonction pour rechercher un médicament par référence avec index et retourner la position
int rechercherPositionMedicamentAvecIndexEtDichotomie(FILE *fichier, Index index[], int nbIndex, int reference) {
    int gauche = 0, droite = nbIndex - 1;

    while (gauche <= droite) {
        int milieu = gauche + (droite - gauche) / 2;

        if (index[milieu].reference == reference) {
            return milieu; // Retourner la position
        } else if (index[milieu].reference < reference) {
            gauche = milieu + 1;
        } else {
            droite = milieu - 1;
        }
    }

    // Retourner -1 si la référence n'est pas trouvée
    return -1;
}


// Fonction pour ajouter un médicament avec index en maintenant l'ordre
void ajouterMedicamentAvecIndexEtIndexEnOrdre(FILE *fichier, Index index[], int *nbIndex, Bloc *bloc, Entete *entete, Medicament nouveauMed) {
    if (ajouterAuBloc(bloc, nouveauMed)) {
        entete->nbrenrg++;
        enregistrerBloc(fichier, *bloc, entete);

        Index newIndex = {nouveauMed.reference, entete->nbbloc - 1, bloc->nb - 1};

        // Ajout de l'index en maintenant l'ordre
        int position = *nbIndex;

        while (position > 0 && index[position - 1].reference > newIndex.reference) {
            index[position] = index[position - 1];
            position--;
        }

        index[position] = newIndex;
        (*nbIndex)++;

        printf("Medicament ajoute avec succes.\n");
    } else {
        enregistrerBloc(fichier, *bloc, entete);
        bloc->nb = 0;
        ajouterAuBloc(bloc, nouveauMed);
        entete->nbrenrg++;
        enregistrerBloc(fichier, *bloc, entete);

        Index newIndex = {nouveauMed.reference, entete->nbbloc - 1, bloc->nb - 1};

        // Ajout de l'index en maintenant l'ordre
        int position = *nbIndex;

        while (position > 0 && index[position - 1].reference > newIndex.reference) {
            index[position] = index[position - 1];
            position--;
        }

        index[position] = newIndex;
        (*nbIndex)++;

        printf("Medicament ajoute avec succes.\n");
    }
}


// Fonction pour supprimer un médicament par référence avec index
bool supprimerMedicamentAvecIndexEtDichotomie(FILE *fichier, Index index[], int *nbIndex, int reference, Entete *entete) {
    int position = rechercherPositionMedicamentAvecIndexEtDichotomie(fichier,index, *nbIndex, reference);

    if (position < *nbIndex && index[position].reference == reference) {
        int i = index[position].bloc;
        int j = index[position].cas;

        Bloc bloc;

        fseek(fichier, i * sizeof(Bloc), SEEK_SET);
        fread(&bloc, sizeof(Bloc), 1, fichier);

        while (j < bloc.nb - 1) {
            bloc.enregistrements[j] = bloc.enregistrements[j + 1];
            j++;
        }

        entete->nbrenrg--;

        if (bloc.nb == 1) {
            entete->nbbloc--;
        }

        fseek(fichier, i * sizeof(Bloc), SEEK_SET);
        fwrite(&bloc, sizeof(Bloc), 1, fichier);

        // Supprimer l'index correspondant
        for (int l = position; l < *nbIndex - 1; l++) {
            index[l] = index[l + 1];
        }

        (*nbIndex)--;

        return true;
    }

    return false;
}


int main() {
    FILE *fichier = fopen("medicaments.dat", "rb+");
    Entete entete;
    entete.nbrenrg = 0;
    entete.nbbloc = 0;

    Bloc bloc;
    bloc.nb = 0;

    Index index[1000];
    int nbIndex = 0;

    int choix;

    do {
        printf("\n1. Ajouter un medicament\n");
        printf("2. Rechercher un medicament\n");
        printf("3. Supprimer un medicament\n");
        printf("4. Quitter\n");
        printf("Choix: ");
        scanf("%d", &choix);

        switch (choix) {
            case 1: {
                // Ajouter un médicament avec index
                Medicament nouveauMed = creerMedicament();
             ajouterMedicamentAvecIndexEtIndexEnOrdre(fichier, index, &nbIndex, &bloc, &entete, nouveauMed);
                break;
            }case 2: {
    // Rechercher un médicament par référence avec index
    int reference;
    printf("Entrez la reference du medicament: ");
    scanf("%d", &reference);

    int position = rechercherPositionMedicamentAvecIndexEtDichotomie(fichier, index, nbIndex, reference);

    if (position != -1) { 

        // Utiliser la position pour obtenir le médicament
        int i = index[position].bloc;
        int j = index[position].cas;

        Bloc bloc;

        fseek(fichier, i * sizeof(Bloc), SEEK_SET);
        fread(&bloc, sizeof(Bloc), 1, fichier);

        Medicament resultat = bloc.enregistrements[j];

        // Afficher les détails du médicament trouvé
        printf("Nom: %s\n", resultat.nom);
        printf("Quantite: %d\n", resultat.qte);
        printf("Prix: %.2f\n", resultat.prix);
        printf("Reference: %d\n", resultat.reference);
        printf("Ingredient: %s\n", resultat.ingredient);
        printf("Date de fabrication: %02d/%02d/%04d\n", resultat.datefabr.jour, resultat.datefabr.mois, resultat.datefabr.annee);
        printf("Date d'expiration: %02d/%02d/%04d\n", resultat.dateexp.jour, resultat.dateexp.mois, resultat.dateexp.annee);
    } else {
        printf("\nMedicament non trouve.\n");
    }
    break;
}

            case 3: {
                // Supprimer un médicament par référence avec index
                int reference;
                printf("Entrez la reference du medicament a supprimer: ");
                scanf("%d", &reference);

if (supprimerMedicamentAvecIndexEtDichotomie(fichier, index, &nbIndex, reference, &entete))
                    {
                    printf("Medicament supprime avec succes.\n");
                } else {
                    printf("Medicament non trouve.\n");
                }
                break;
            }
            case 4:
                printf("Programme termine.\n");
                break;
            default:
                printf("Choix invalide. Veuillez reessayer.\n");
                break;
        }
    } while (choix != 4);

    fclose(fichier);

    return 0;
}
